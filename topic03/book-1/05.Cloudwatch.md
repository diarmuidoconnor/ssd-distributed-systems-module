## Debugging with Cloudwatch. 

----------------------
### Tidy-up.

We should do some cleanup before working through this section. In the management console, go to the Cloudwatch service --> Log groups and delete all the groups by selecting them and choosing the Delete action: 

![][deletelog]

-----------------------------

In `lambdas/getMovieById.ts`, the handler starts by logging the event object to the console. We can use the output from this log statement to explore the shape of the event object. First, in a browser tab, trigger the function by requesting a movie (say, 572802). Then, in the management console, go to  CloudWatch --> Log Groups (left panel) --> Select the '/aws/lambda/SimpleAppStack-GetMovieByIdFn' group --> Select the Log steam --> Expand the stream section generated by the console log statement: 

![][eventshape1]

Locate the query string parameter in the structure:

![][eventshape2]

Cloudwatch is also useful when examining the structure of responses from the DynamoDB SDK (or any service SDK). For example, add a console log statement to `getMovieById.ts` as follows:
~~~ts
   const commandOutput = await ddbDocClient.send(
     ... as before ...
    );
    console.log('GetCommand response: ', commandOutput)  // NEW
    if (!commandOutput.Item) {
      ... as before ...
~~~
Update the stack (cdk deploy), and resubmit a request for movie 572802 from the browser tab. The Cloudwatch log stream for the new log statement looks as follows:

![][getcommand]

A common error when developing lambda functions is insufficient IAM permissions to access other AWS services, such as DynamoDB. In `simple-app-stack.ts` comment out the line:
~~~ts
   // moviesTable.grantReadData(getMovieByIdFn)
~~~

Update the stack (cdk deploy) and try requesting movie 572802 from the browser again. An error response is returned this time:

![][accessdenied1]

In cases where a lanbda function is not triggered by a browser request, we need another means of identifying the error thrown. To simulate this, temporarily comment out the catch-block in `getMovieById.ts`. An outline of the function looks as follows:
~~~js
export const handler: APIGatewayProxyHandlerV2 = async (event, context) => {
//   try {
    console.log("Event: ", JSON.stringify(event));
    . . . . as before . . . . . 
    // Return Response
    return {
      statusCode: 200,
      headers: {
        "content-type": "application/json",
      },
      body: JSON.stringify(body),
    };
//   } catch (error: any) {
//     console.log(JSON.stringify(error));
//     return {
//       statusCode: 500,
//       headers: {
//         "content-type": "application/json",
//       },
//       body: JSON.stringify({ error }),
//     };
//   }
};
~~~

Update the stack (cdk deploy) and try requesting movie 572802. This time we get a generic 'Internal Server Error'. To debug this, go to Cloudwatch and find the log stream for this invocation of the function:

![][accessdenied2]

An AccessDeniedException error typically means the lambda function needs more IAM permissions to complete successfully. You will often need to debug lambda functions via CloudWatch logs in this way. 

__Undo all the above code changes__, update the stack and check the get movie feature is working again.


[accessdenied1]: ./img/accessdenied1.png
[accessdenied2]: ./img/accessdenied2.png
[eventshape1]: ./img/eventshape1.png
[eventshape2]: ./img/eventshape2.png
[getcommand]: ./img/getcommand.png
[deletelog]: ./img/deletelog.png
